# ğŸ”Œ Interfaces e Classes Abstratas em Python

## âœ… O que sÃ£o Interfaces em ProgramaÃ§Ã£o?

Uma **interface** define um **contrato** sobre o que uma classe deve fazer â€” ou seja, **quais mÃ©todos ela precisa ter**, mas **nÃ£o define como esses mÃ©todos devem funcionar**.

> Ã‰ como um manual de instruÃ§Ãµes: vocÃª sabe o que tem que fazer, mas decide como fazer.

Interfaces sÃ£o Ãºteis para garantir que diferentes classes tenham um comportamento esperado em comum, mesmo que a implementaÃ§Ã£o seja diferente.

---

## ğŸ¯ Para que serve uma Interface?

- Garantir **consistÃªncia** entre diferentes implementaÃ§Ãµes.
- Estimular o uso de **polimorfismo** e programaÃ§Ã£o orientada a abstraÃ§Ãµes.
- Facilitar testes, manutenÃ§Ã£o e extensÃ£o do sistema.

---

## ğŸ¤” Python tem Interface?

Python **nÃ£o possui o conceito tradicional de Interface** (como Java ou C#), mas podemos **simular interfaces** utilizando **classes abstratas**, com a ajuda do mÃ³dulo `abc` (Abstract Base Classes).

---

## ğŸ“¦ O que Ã© o MÃ³dulo `abc`?

O mÃ³dulo `abc` permite criar **classes abstratas** e marcar mÃ©todos como **abstratos** com o decorador `@abstractmethod`.

> Uma **classe abstrata** Ã© aquela que **nÃ£o pode ser instanciada diretamente**, e serve de modelo para outras classes.

```python
from abc import ABC, abstractmethod

class Animal(ABC):  # herda de ABC (Abstract Base Class)
    @abstractmethod
    def emitir_som(self):
        pass
```

---

## ğŸ’¡ O que Ã© uma Assinatura de MÃ©todo?

A **assinatura de um mÃ©todo** Ã© composta por:

- Seu **nome**
- E a **quantidade e tipo de parÃ¢metros** esperados

```python
def emitir_som(self):  # assinatura do mÃ©todo
    ...
```

---

## ğŸ› ï¸ Criando uma Classe Abstrata

```python
from abc import ABC, abstractmethod

class FormaGeometrica(ABC):

    @abstractmethod
    def calcular_area(self):
        pass
```

### ğŸ‘‡ Criando uma Classe Concreta que implementa a Abstrata

```python
class Quadrado(FormaGeometrica):
    def __init__(self, lado):
        self.lado = lado

    def calcular_area(self):
        return self.lado ** 2
```

### âš ï¸ Tentativa de instanciar sem implementar gera erro

```python
forma = FormaGeometrica()  
# TypeError: Can't instantiate abstract class FormaGeometrica with abstract methods calcular_area
```

---

## ğŸ§ª Exemplo PrÃ¡tico: Interface para VeÃ­culos

```python
from abc import ABC, abstractmethod

class Veiculo(ABC):
    @abstractmethod
    def ligar(self):
        pass

    @abstractmethod
    def desligar(self):
        pass

class Carro(Veiculo):
    def ligar(self):
        print("Carro ligado")

    def desligar(self):
        print("Carro desligado")

# Uso
carro = Carro()
carro.ligar()     # Carro ligado
carro.desligar()  # Carro desligado
```

---

## ğŸ‘ Boas PrÃ¡ticas com Interfaces e Classes Abstratas

- Use interfaces para definir **comportamentos esperados** entre classes.
- Evite usar `@abstractmethod` em mÃ©todos que vocÃª jÃ¡ implementou completamente.
- Sempre implemente **todos os mÃ©todos abstratos** nas subclasses.
- Prefira interfaces quando quiser garantir **contratos de implementaÃ§Ã£o** entre vÃ¡rias classes.

---

## ğŸ“Œ ConclusÃ£o

- Python nÃ£o possui interface nativa, mas usamos classes abstratas para simular esse comportamento.
- A interface define **"o que fazer"**, e a implementaÃ§Ã£o em cada classe concreta define **"como fazer"**.
- O mÃ³dulo `abc` fornece as ferramentas necessÃ¡rias para isso.

---

âœï¸ Autor: [Andre Almeida](https://github.com/llandrell)  

