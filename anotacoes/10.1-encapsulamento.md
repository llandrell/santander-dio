
# ğŸ”’ Encapsulamento em Python

## ğŸ“˜ O que Ã© Encapsulamento?

Encapsulamento Ã© um dos **pilares da programaÃ§Ã£o orientada a objetos (POO)**.  
Seu objetivo Ã© **restringir o acesso direto aos dados internos de um objeto**, protegendo o estado interno e fornecendo uma interface controlada para interaÃ§Ã£o.

Em outras palavras, **encapsular** Ã© esconder os detalhes de implementaÃ§Ã£o e expor apenas o necessÃ¡rio.

---

## ğŸ”§ Como Ã© implementado em Python?

Python nÃ£o possui modificadores de acesso como `private`, `protected`, `public` das linguagens como Java ou C++,  
mas sim **convenÃ§Ãµes de nomenclatura** para indicar o nÃ­vel de acesso:

| Modificador | Prefixo | Visibilidade | Exemplo       |
|-------------|---------|--------------|---------------|
| PÃºblico     | nenhum  | livre        | `self.nome`   |
| Protegido   | `_`     | interno      | `self._idade` |
| Privado     | `__`    | restrito     | `self.__cpf`  |

---

## ğŸ›¡ï¸ Atributos PÃºblicos, Protegidos e Privados

```python
class Pessoa:
    def __init__(self, nome, idade, cpf):
        self.nome = nome           # pÃºblico
        self._idade = idade        # protegido (convenÃ§Ã£o)
        self.__cpf = cpf           # privado (name mangling)
```

### ğŸ§ª Acessando os atributos
```python
p = Pessoa("Ana", 30, "123.456.789-00")
print(p.nome)      # OK
print(p._idade)    # OK (mas nÃ£o recomendado)
# print(p.__cpf)   # Erro: atributo inacessÃ­vel
print(p._Pessoa__cpf)  # Funciona, mas nÃ£o deve ser feito
```

---

## âœ… Por que usar Encapsulamento?

- **Evita manipulaÃ§Ã£o incorreta** dos dados.
- **Garante seguranÃ§a** do estado interno do objeto.
- **Facilita manutenÃ§Ã£o e extensibilidade**.
- **Oculta detalhes da implementaÃ§Ã£o**.

---

## ğŸ“¦ `@property` em Python

O decorador `@property` permite **transformar mÃ©todos em atributos acessÃ­veis**, tornando a leitura mais intuitiva e mantendo o controle.

### ğŸ”¹ Exemplo de uso:

```python
class Produto:
    def __init__(self, nome, preco):
        self.nome = nome
        self._preco = preco

    @property
    def preco(self):
        return self._preco

    @preco.setter
    def preco(self, novo_preco):
        if novo_preco > 0:
            self._preco = novo_preco
        else:
            print("âŒ PreÃ§o invÃ¡lido.")
```

### ğŸ§ª UtilizaÃ§Ã£o
```python
p = Produto("Notebook", 3500)
print(p.preco)      # Acessa como atributo (3500)
p.preco = 4000      # Usa mÃ©todo setter
print(p.preco)      # Agora: 4000
p.preco = -200      # âŒ PreÃ§o invÃ¡lido
```

---

## ğŸ§  Resumo das Boas PrÃ¡ticas

- Prefira acessar atributos sensÃ­veis via mÃ©todos (getters/setters).
- Use `@property` para facilitar o uso sem abrir mÃ£o do controle.
- Use `_atributo` para indicar que o atributo **nÃ£o deve ser acessado diretamente**.
- Use `__atributo` quando realmente quiser ocultar (name mangling).

---

âœï¸ Autor: [Andre Almeida](https://github.com/llandrell)  
ğŸ“ Local: `/anotacoes/encapsulamento_python.md`