
# 🔒 Encapsulamento em Python

## 📘 O que é Encapsulamento?

Encapsulamento é um dos **pilares da programação orientada a objetos (POO)**.  
Seu objetivo é **restringir o acesso direto aos dados internos de um objeto**, protegendo o estado interno e fornecendo uma interface controlada para interação.

Em outras palavras, **encapsular** é esconder os detalhes de implementação e expor apenas o necessário.

---

## 🔧 Como é implementado em Python?

Python não possui modificadores de acesso como `private`, `protected`, `public` das linguagens como Java ou C++,  
mas sim **convenções de nomenclatura** para indicar o nível de acesso:

| Modificador | Prefixo | Visibilidade | Exemplo       |
|-------------|---------|--------------|---------------|
| Público     | nenhum  | livre        | `self.nome`   |
| Protegido   | `_`     | interno      | `self._idade` |
| Privado     | `__`    | restrito     | `self.__cpf`  |

---

## 🛡️ Atributos Públicos, Protegidos e Privados

```python
class Pessoa:
    def __init__(self, nome, idade, cpf):
        self.nome = nome           # público
        self._idade = idade        # protegido (convenção)
        self.__cpf = cpf           # privado (name mangling)
```

### 🧪 Acessando os atributos
```python
p = Pessoa("Ana", 30, "123.456.789-00")
print(p.nome)      # OK
print(p._idade)    # OK (mas não recomendado)
# print(p.__cpf)   # Erro: atributo inacessível
print(p._Pessoa__cpf)  # Funciona, mas não deve ser feito
```

---

## ✅ Por que usar Encapsulamento?

- **Evita manipulação incorreta** dos dados.
- **Garante segurança** do estado interno do objeto.
- **Facilita manutenção e extensibilidade**.
- **Oculta detalhes da implementação**.

---

## 📦 `@property` em Python

O decorador `@property` permite **transformar métodos em atributos acessíveis**, tornando a leitura mais intuitiva e mantendo o controle.

### 🔹 Exemplo de uso:

```python
class Produto:
    def __init__(self, nome, preco):
        self.nome = nome
        self._preco = preco

    @property
    def preco(self):
        return self._preco

    @preco.setter
    def preco(self, novo_preco):
        if novo_preco > 0:
            self._preco = novo_preco
        else:
            print("❌ Preço inválido.")
```

### 🧪 Utilização
```python
p = Produto("Notebook", 3500)
print(p.preco)      # Acessa como atributo (3500)
p.preco = 4000      # Usa método setter
print(p.preco)      # Agora: 4000
p.preco = -200      # ❌ Preço inválido
```

---

## 🧠 Resumo das Boas Práticas

- Prefira acessar atributos sensíveis via métodos (getters/setters).
- Use `@property` para facilitar o uso sem abrir mão do controle.
- Use `_atributo` para indicar que o atributo **não deve ser acessado diretamente**.
- Use `__atributo` quando realmente quiser ocultar (name mangling).

---

✍️ Autor: [Andre Almeida](https://github.com/llandrell)  
📁 Local: `/anotacoes/encapsulamento_python.md`